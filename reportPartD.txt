These programs do not experience deadlock or livelock. Since the programs are only sharing one resource, the rubric file, no circular wait condition can occur, so deadlock cannot occur. With these programs, livelock also does not occur, since the programs do not directly react to each other's actions. At least one program is always doing useful work and making progress, so neither deadlock nor livelock occur.

In Part A and Part B, execution starts with the main process creating the number of TAs specified in argv, forking and then execing the child processes into TA processes. It then waits for a TA to terminate successfully.

Each TA process opens a student file, getting a student number. If the number is 9999, the TA terminates successfully. If not, the TA randomly picks an exam question, opens the rubric file, and loads the rubric into a string. It then waits 0.75 to 1.25s, and then has a 1 in 2 chance of editing the rubric. If the result is to edit the rubric, it edits the corresponding quesiton by increasing the ASCII character by 1 position (unless it is Z, which will become A), and then writing back to the text file. Either way, it then waits for 2.5 to 3.5s and then repeats the process again.

Once a TA process terminates successfully, main stops waiting and kills all the other TA processes, waiting on them afterward to prevent zombie processes. Main then exits itself, ending the execution.

In Part A, as each TA copies the rubric into a local string, if another TA changes the rubric while the TA is marking a student, the TA will not know. Also, because of the local string, if multiple TAs edit the file in quick succession, they will keep overwriting each other's changes, as the TA's edited string does not contain the changes that happened since the TA last read the rubric file. This is solved in Part B by using a semaphore to limit the access of the rubric to 1 TA at a time.

In Part B, a semaphore is used to regulate the access to the rubric file, allowing only one access at a time. Main creates the semaphore, initializing its value to 1. Each TA opens the semaphore, and then calls sem_wait() every time it wants access to the rubric. If no other TA is accessing the rubric, the semaphore value will be 1, so sem_wait() will set its value to 0 and allow the TA to continue processing. If another TA is accessing the rubric, sem_wait() will stop the TA from progressing further, until it gets a turn to access the rubric exclusively. When the TA is done with the rubric, it uses sem_post to indicate it is finished and to set the semaphore value to 1. By doing this, it prevents the TAs from overwriting each other's changes, and ensures that the TAs are always viewing and editing the most up to date rubric.

The critical secton problem has three requirements which must be met to solve it: Mutual Exclusion, Progress, and Busy Waiting. The solution in Part B solves meets these three requirements, and therefore solves the critical section problem. It meets the Mutual Exclusion requirement by ensuring only one process (TA) can access the shared resource (rubric) in the critical section at a time. This is because the semaphore value is set to 1 on initialization, and whenever a process accesses the critical section, it uses wait to set the value to 0, until it leaves and posts the value back to 1. The next process waits until the semaphore value is nonzero, before setting it to 0 and entering the critical section. This solution also meets the Progress requirement, since every process posts the semaphore when finished with the critical section, setting the sempahore value back to 1. This ensures that a waiting process can enter as soon as the previous process is finished, preventing a process from waiting while the critical section is empty. Finally, this solution meets the bounded waiting reqiurement, as each process has an equal priority to enter the critical section, and the processes wait in a queue before entering. Because of this, the processes enter their critical sections in the order that they wait for it, meaning that there is a limit on the number of processes that can enter their critical sections before any given process (only the processes that have requested before). By satisfying these three requirements, the solution in Part B solves the critical section problem.